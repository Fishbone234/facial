import time
import random
import math

class FaceRecognitionSimulator:
    def __init__(self):
        # ç”¨æˆ·æ•°æ®åº“
        self.users = {
            "å¼ ä¸‰": {
                "features": self._generate_features("å¼ ä¸‰"),
                "description": "æ–¹è„¸ï¼Œæˆ´çœ¼é•œï¼ŒçŸ­å‘"
            },
            "æå››": {
                "features": self._generate_features("æå››"),
                "description": "åœ†è„¸ï¼Œæœ‰èƒ¡å­ï¼Œå¹³å¤´"
            },
            "ç‹äº”": {
                "features": self._generate_features("ç‹äº”"),
                "description": "é•¿è„¸ï¼Œæœ‰é…’çªï¼Œåˆ†å¤´"
            },
            "èµµå…­": {
                "features": self._generate_features("èµµå…­"),
                "description": "æ¤­åœ†è„¸ï¼Œæˆ´è€³ç¯ï¼Œå·å‘"
            }
        }
        self.threshold = 0.75  # è¯†åˆ«é˜ˆå€¼
        
    def _generate_features(self, seed_str):
        """æ ¹æ®åå­—ç”Ÿæˆå”¯ä¸€çš„ç‰¹å¾å‘é‡"""
        # ä½¿ç”¨åå­—çš„å“ˆå¸Œå€¼ä½œä¸ºéšæœºç§å­
        random.seed(hash(seed_str))
        features = []
        for _ in range(10):  # 10ç»´ç‰¹å¾å‘é‡
            features.append(random.random())
        return features
    
    def _cosine_similarity(self, vec1, vec2):
        """è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦"""
        dot_product = sum(a * b for a, b in zip(vec1, vec2))
        norm1 = math.sqrt(sum(a * a for a in vec1))
        norm2 = math.sqrt(sum(b * b for b in vec2))
        
        if norm1 == 0 or norm2 == 0:
            return 0
        return dot_product / (norm1 * norm2)
    
    def _animate_text(self, text, delay=0.05):
        """æ‰“å­—æœºæ•ˆæœæ˜¾ç¤ºæ–‡æœ¬"""
        for char in text:
            print(char, end='', flush=True)
            time.sleep(delay)
        print()
    
    def _print_box(self, title, content):
        """æ‰“å°å¸¦è¾¹æ¡†çš„æ–‡æœ¬"""
        width = max(len(title), max(len(line) for line in content.split('\n'))) + 4
        print("â•”" + "â•" * (width - 2) + "â•—")
        print("â•‘ " + title.center(width - 3) + "â•‘")
        print("â• " + "â•" * (width - 2) + "â•£")
        for line in content.split('\n'):
            print("â•‘ " + line.ljust(width - 3) + "â•‘")
        print("â•š" + "â•" * (width - 2) + "â•")
    
    def detect_face(self):
        """æ¨¡æ‹Ÿäººè„¸æ£€æµ‹"""
        self._animate_text("[ç³»ç»Ÿ] å¯åŠ¨æ‘„åƒå¤´...")
        time.sleep(0.8)
        
        # éšæœºé€‰æ‹©ä¸€ä¸ªç”¨æˆ·æˆ–é™Œç”Ÿäºº
        all_choices = list(self.users.keys()) + ["é™Œç”Ÿäºº"]
        target = random.choice(all_choices)
        
        if target == "é™Œç”Ÿäºº":
            self._animate_text("[æ‘„åƒå¤´] æ£€æµ‹åˆ°æœªæ³¨å†Œäººå‘˜")
            description = "æœªçŸ¥é¢å­”ï¼Œä¸åœ¨æ•°æ®åº“ä¸­"
        else:
            self._animate_text(f"[æ‘„åƒå¤´] æ£€æµ‹åˆ°äººè„¸")
            description = self.users[target]["description"]
            
        self._animate_text(f"[ç³»ç»Ÿ] äººç‰©æè¿°: {description}")
        return target
    
    def extract_features(self, target):
        """æ¨¡æ‹Ÿç‰¹å¾æå–"""
        self._animate_text("\n[ç³»ç»Ÿ] å¼€å§‹ç‰¹å¾æå–...")
        time.sleep(0.5)
        
        # æ¨¡æ‹Ÿå…³é”®ç‚¹æ£€æµ‹
        keypoints = ["å·¦çœ¼", "å³çœ¼", "é¼»å°–", "å·¦å˜´è§’", "å³å˜´è§’"]
        self._animate_text(f"[ç®—æ³•] å®šä½é¢éƒ¨å…³é”®ç‚¹: {', '.join(keypoints)}")
        time.sleep(0.5)
        
        # ç”Ÿæˆç‰¹å¾å‘é‡
        if target in self.users:
            base_features = self.users[target]["features"]
            # æ·»åŠ å°‘é‡å™ªå£°æ¨¡æ‹ŸçœŸå®æƒ…å†µ
            features = [f + random.uniform(-0.1, 0.1) for f in base_features]
        else:
            features = [random.random() for _ in range(10)]
            
        self._animate_text(f"[ç®—æ³•] ç”Ÿæˆç‰¹å¾å‘é‡: [{features[0]:.2f}, {features[1]:.2f}, ...]")
        return features
    
    def match_in_database(self, features):
        """åœ¨æ•°æ®åº“ä¸­åŒ¹é…"""
        self._animate_text("\n[ç³»ç»Ÿ] æ­£åœ¨æ•°æ®åº“ä¸­è¿›è¡ŒåŒ¹é…...")
        time.sleep(0.7)
        
        best_match = None
        best_score = 0
        
        print("\n[ç³»ç»Ÿ] æ¯”å¯¹ç»“æœ:")
        for name, user_data in self.users.items():
            similarity = self._cosine_similarity(features, user_data["features"])
            similarity = round(similarity, 3)
            
            # å¯è§†åŒ–ç›¸ä¼¼åº¦æ¡
            bar_length = 20
            filled = int(similarity * bar_length)
            bar = "â–ˆ" * filled + "â–‘" * (bar_length - filled)
            
            print(f"  {name:<4} â–{bar}â– {similarity*100:5.1f}%")
            
            if similarity > best_score:
                best_score = similarity
                best_match = name
                
            time.sleep(0.2)
            
        return best_match, best_score
    
    def liveness_detection(self):
        """æ¨¡æ‹Ÿæ´»ä½“æ£€æµ‹"""
        self._animate_text("\n[ç³»ç»Ÿ] å¼€å§‹æ´»ä½“æ£€æµ‹...")
        time.sleep(0.5)
        
        tests = [
            ("çº¢å¤–æ£€æµ‹", 0.95),
            ("3Dæ·±åº¦æ£€æµ‹", 0.90),
            ("çœ¨çœ¼æ£€æµ‹", 0.85),
            ("å”‡åŠ¨æ£€æµ‹", 0.88)
        ]
        
        all_passed = True
        for test_name, success_rate in tests:
            passed = random.random() < success_rate
            status = "âœ“ é€šè¿‡" if passed else "âœ— å¤±è´¥"
            print(f"  {test_name:12} -> {status}")
            
            if not passed:
                all_passed = False
                print(f"    [è­¦å‘Š] æ£€æµ‹åˆ°å¼‚å¸¸: å¯èƒ½æ˜¯ç…§ç‰‡æˆ–è§†é¢‘æ”»å‡»")
                
            time.sleep(0.3)
            
        return all_passed
    
    def simulate_recognition(self):
        """è¿è¡Œä¸€æ¬¡å®Œæ•´çš„äººè„¸è¯†åˆ«æ¨¡æ‹Ÿ"""
        print("\n" + "="*60)
        print("äººè„¸è¯†åˆ«ç³»ç»Ÿæ¨¡æ‹Ÿ".center(60))
        print("="*60)
        
        # 1. äººè„¸æ£€æµ‹
        target = self.detect_face()
        
        # 2. ç‰¹å¾æå–
        features = self.extract_features(target)
        
        # 3. æ•°æ®åº“åŒ¹é…
        matched_name, score = self.match_in_database(features)
        
        # 4. æ´»ä½“æ£€æµ‹
        is_live = self.liveness_detection()
        
        # 5. æ˜¾ç¤ºæœ€ç»ˆç»“æœ
        print("\n" + "="*60)
        print("è¯†åˆ«ç»“æœ".center(60))
        print("="*60)
        
        if not is_live:
            result = "âŒ éªŒè¯å¤±è´¥"
            reason = "æ´»ä½“æ£€æµ‹æœªé€šè¿‡"
        elif matched_name and score >= self.threshold:
            result = "âœ… è¯†åˆ«æˆåŠŸ"
            reason = f"åŒ¹é…ç”¨æˆ·: {matched_name}"
        else:
            result = "â“ æœªçŸ¥äººå‘˜"
            reason = "æœªåœ¨æ•°æ®åº“ä¸­æ‰¾åˆ°åŒ¹é…"
        
        # åˆ›å»ºç»“æœæŠ¥å‘Š
        report = f"""
        è¯†åˆ«çŠ¶æ€: {result}
        ç½®ä¿¡åº¦: {score*100:.1f}%
        é˜ˆå€¼è¦æ±‚: {self.threshold*100:.1f}%
        æ´»ä½“æ£€æµ‹: {'é€šè¿‡' if is_live else 'å¤±è´¥'}
        è¯¦ç»†åŸå› : {reason}
        
        """
        
        # æ¨¡æ‹Ÿåº”ç”¨åœºæ™¯
        if result == "âœ… è¯†åˆ«æˆåŠŸ":
            scenarios = [
                "ğŸ“± æ‰‹æœºè§£é”æˆåŠŸ",
                "ğŸšª é—¨ç¦ç³»ç»Ÿå¼€å¯",
                "ğŸ’° æ”¯ä»˜éªŒè¯é€šè¿‡",
                "ğŸ•’ è€ƒå‹¤æ‰“å¡æˆåŠŸ"
            ]
            scenario = random.choice(scenarios)
            report += f"        åº”ç”¨åœºæ™¯: {scenario}"
        
        self._print_box("äººè„¸è¯†åˆ«æŠ¥å‘Š", report.strip())
        
        # è¿”å›ç»“æœä¾›ç»Ÿè®¡
        return {
            "target": target,
            "matched": matched_name,
            "score": score,
            "success": result == "âœ… è¯†åˆ«æˆåŠŸ",
            "is_live": is_live
        }

def main():
    """ä¸»ç¨‹åº"""
    print("åˆå§‹åŒ–äººè„¸è¯†åˆ«ç³»ç»Ÿ...")
    time.sleep(1)
    
    # åˆ›å»ºæ¨¡æ‹Ÿå™¨
    simulator = FaceRecognitionSimulator()
    
    # æ˜¾ç¤ºç³»ç»Ÿä¿¡æ¯
    print("\n" + "â–„" * 60)
    print("ç³»ç»Ÿä¿¡æ¯".center(60))
    print("â–€" * 60)
    print(f"â€¢ æ³¨å†Œç”¨æˆ·æ•°: {len(simulator.users)}")
    print(f"â€¢ è¯†åˆ«é˜ˆå€¼: {simulator.threshold*100}%")
    print(f"â€¢ ç‰¹å¾ç»´åº¦: 10ç»´å‘é‡")
    print(f"â€¢ æ´»ä½“æ£€æµ‹: å¯ç”¨")
    print("-" * 60)
    
    # è¿è¡Œå¤šæ¬¡æ¨¡æ‹Ÿ
    results = []
    num_simulations = 5
    
    input("\næŒ‰ Enter é”®å¼€å§‹æ¨¡æ‹Ÿäººè„¸è¯†åˆ«...")
    
    for i in range(num_simulations):
        print(f"\n\nç¬¬ {i+1} æ¬¡è¯†åˆ«å°è¯•".center(60, "âœ¦"))
        result = simulator.simulate_recognition()
        results.append(result)
        
        if i < num_simulations - 1:
            input("\næŒ‰ Enter é”®ç»§ç»­ä¸‹ä¸€æ¬¡è¯†åˆ«...")
    
    # æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    print("\n" + "="*60)
    print("è¯†åˆ«ç»Ÿè®¡".center(60))
    print("="*60)
    
    total = len(results)
    success_count = sum(1 for r in results if r["success"])
    live_count = sum(1 for r in results if r["is_live"])
    
    stats = f"""
    æ€»è¯†åˆ«æ¬¡æ•°: {total}
    æˆåŠŸè¯†åˆ«: {success_count} ({success_count/total*100:.1f}%)
    æ´»ä½“é€šè¿‡: {live_count} ({live_count/total*100:.1f}%)
    å¹³å‡ç½®ä¿¡åº¦: {sum(r['score'] for r in results)/total*100:.1f}%
    
    è¯¦ç»†è®°å½•:
    """
    
    for i, r in enumerate(results, 1):
        status = "æˆåŠŸ" if r["success"] else "å¤±è´¥"
        stats += f"    {i}. {r['target']} -> {r['matched'] or 'æ— '} ({status})\n"
    
    print(stats)
    print("="*60)
    print("\næ¨¡æ‹Ÿç»“æŸï¼Œæ„Ÿè°¢ä½¿ç”¨äººè„¸è¯†åˆ«ç³»ç»Ÿï¼")

if __name__ == "__main__":
    main()
